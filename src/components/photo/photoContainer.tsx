// PhotoContainer.tsx
import { useEffect, useRef, useState } from "react";
import { useBatyrStore } from "./module/useBatyrStore.ts";
// ‚úÖ 1. –ò–ú–ü–û–†–¢–ò–†–£–ï–ú –ù–û–í–£–Æ –§–£–ù–ö–¶–ò–Æ
import { getTaskStatus, startFaceSwapTask, downloadImageProxy } from "./api";
import Photo from "./ui/photo.tsx";

const POLLING_TIMEOUT_SECONDS = 180;

const PhotoContainer = () => {
    const {
        step, setStep,
        userPhoto, setUserPhoto,
        preview, setPreview,
        loading, setLoading,
        resultUrl, setResultUrl,
        jobId, setJobId,
        clearAll,
        isPolling, setIsPolling,
    } = useBatyrStore();

    const [isDownloading, setIsDownloading] = useState(false);

    const intervalRef = useRef<NodeJS.Timeout | null>(null);
    const pollingStartTimeRef = useRef<number | null>(null);

    const clearLocalStorage = () => {
        localStorage.removeItem("batyr_job_id");
        localStorage.removeItem("batyr_result_url");
        localStorage.removeItem("batyr_preview");
    };

    const startPolling = (currentJobId: string) => {
        if (isPolling || intervalRef.current) return;
        console.log(`üöÄ –ù–∞—á–∏–Ω–∞–µ–º –æ–ø—Ä–æ—Å –¥–ª—è Job ID: ${currentJobId}`);
        setIsPolling(true);
        pollingStartTimeRef.current = Date.now();
        intervalRef.current = setInterval(async () => {
            if (Date.now() - (pollingStartTimeRef.current ?? 0) > POLLING_TIMEOUT_SECONDS * 1000) {
                console.error("‚è±Ô∏è –¢–∞–π–º–∞—É—Ç –æ–ø—Ä–æ—Å–∞ –∏—Å—Ç–µ–∫.");
                alert("–í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
                handleClear();
                return;
            }
            try {
                const data = await getTaskStatus(currentJobId);
                console.log(`‚åõ –°—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ [${currentJobId}]: ${data.status}`);
                if (data.status === "completed") {
                    console.log("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–ª—É—á–µ–Ω!", data.result_url);
                    stopPolling();
                    setResultUrl(data.result_url);
                    setLoading(false);
                    localStorage.setItem("batyr_result_url", data.result_url);
                    if (preview) {
                        localStorage.setItem("batyr_preview", preview);
                    }
                    localStorage.removeItem("batyr_job_id");
                    return;
                }
                if (data.status === "failed") {
                    console.error("‚ùå –ó–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π:", data.error);
                    alert(`–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${data.error || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ"}`);
                    handleClear();
                    return;
                }
            } catch (err) {
                console.error("üî• –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–æ—Å–µ —Å—Ç–∞—Ç—É—Å–∞:", err);
                alert("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
                handleClear();
            }
        }, 5000);
    };

    const stopPolling = () => {
        if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
        }
        setIsPolling(false);
        pollingStartTimeRef.current = null;
        console.log("üõë –û–ø—Ä–æ—Å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.");
    };

    useEffect(() => {
        // @ts-ignore
        const tg = window.Telegram?.WebApp;
        if (!tg) {
            console.error("–û–∫—Ä—É–∂–µ–Ω–∏–µ Telegram Web App –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!");
            return;
        }
        tg.ready();
        const storedJobId = localStorage.getItem("batyr_job_id");
        const storedResultUrl = localStorage.getItem("batyr_result_url");
        const storedPreview = localStorage.getItem("batyr_preview");
        if (storedResultUrl && storedPreview) {
            setPreview(storedPreview);
            setResultUrl(storedResultUrl);
            setStep(2);
            setLoading(false);
            return;
        }
        if (storedJobId) {
            setJobId(storedJobId);
            setPreview(storedPreview || null);
            setStep(2);
            setLoading(true);
            startPolling(storedJobId);
            return;
        }
        handleClear();
        return () => stopPolling();
    }, []);

    const handleNext = async () => {
        if (!userPhoto || loading) return;
        setStep(2);
        setLoading(true);
        setResultUrl(null);
        clearLocalStorage();
        try {
            const data = await startFaceSwapTask(userPhoto);
            const newJobId = data.job_id;
            if (newJobId) {
                setJobId(newJobId);
                localStorage.setItem("batyr_job_id", newJobId);
                if (preview) {
                    localStorage.setItem("batyr_preview", preview);
                }
                startPolling(newJobId);
            } else {
                alert("–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
                handleClear();
            }
        } catch (err) {
            const errorMessage = (err as Error)?.message || "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞.";
            alert(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ: ${errorMessage}`);
            handleClear();
        }
    };

    const handleClear = () => {
        stopPolling();
        clearLocalStorage();
        clearAll();
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            handleClear();
            const previewUrl = URL.createObjectURL(file);
            setUserPhoto(file);
            setPreview(previewUrl);
        }
    };

    // ‚úÖ 2. –ò–ó–ú–ï–ù–ï–ù–û: –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–æ–∫—Å–∏ –Ω–∞ –±—ç–∫–µ–Ω–¥–µ
    const downloadImage = async () => {
        if (!resultUrl || isDownloading) return;

        setIsDownloading(true);

        try {
            // –í—ã–∑—ã–≤–∞–µ–º –Ω–∞—à—É –Ω–æ–≤—É—é API —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
            const imageBlob = await downloadImageProxy(resultUrl);

            // –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ –∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –æ—Å—Ç–∞–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–µ–π
            const localUrl = URL.createObjectURL(imageBlob);
            const link = document.createElement("a");
            link.href = localUrl;
            link.download = "batyr-result.jpg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(localUrl);

        } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞:", error);
            alert(`–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª: ${(error as Error).message}`);
        } finally {
            setIsDownloading(false);
        }
    };

    return (
        <Photo
            step={step}
            preview={preview}
            loading={loading}
            resultUrl={resultUrl}
            userPhoto={userPhoto}
            onNext={handleNext}
            onClear={handleClear}
            onFileChange={handleFileChange}
            onDownload={downloadImage}
            isDownloading={isDownloading}
        />
    );
};

export default PhotoContainer;